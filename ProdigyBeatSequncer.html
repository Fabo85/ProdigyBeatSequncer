<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prodigy Beast Sequencer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap');
        
        body {
            background-color: #1a1a1a;
            color: #e0e0e0;
            font-family: 'Roboto Mono', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            margin: 0;
            box-sizing: border-box;
            background-image: radial-gradient(circle, #333 1px, transparent 1px);
            background-size: 15px 15px;
        }

        .container {
            width: 100%;
            max-width: 1400px;
            background-color: #222;
            border: 2px solid #00ff80;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 255, 128, 0.3);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        h1 {
            color: #00ff80;
            text-align: center;
            font-size: 3rem;
            text-shadow: 0 0 10px #00ff80;
            margin-bottom: 10px;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #333;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #444;
            flex-wrap: wrap;
            gap: 10px;
        }

        .controls button, .controls select {
            padding: 10px 20px;
            border-radius: 5px;
            border: none;
            font-family: 'Roboto Mono', monospace;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .controls .transport button {
            background-color: #00ff80;
            color: #1a1a1a;
        }

        .controls .transport button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 255, 128, 0.4);
        }

        .controls .transport button.playing {
            background-color: #e74c3c;
            box-shadow: 0 0 15px #e74c3c;
        }
        
        .controls .transport button:disabled {
            background-color: #555;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        .tempo-control, .length-control {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #00ff80;
            font-size: 1.2rem;
        }

        .length-control select {
            background-color: #444;
            color: #e0e0e0;
            border: 1px solid #00ff80;
        }

        .sliders {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 10px;
            background-color: #333;
            flex-wrap: wrap;
            gap: 15px;
        }

        .slider-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            color: #00ff80;
            min-width: 120px;
            text-align: center;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #555;
            border-radius: 5px;
            outline: none;
            transition: opacity .2s;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #00ff80;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #00ff80;
            border-radius: 50%;
            cursor: pointer;
        }

        .grid-container {
            width: 100%;
            overflow-x: auto;
            border: 1px solid #444;
            border-radius: 10px;
            padding: 10px;
            background-color: #333;
        }

        .sequencer-grid {
            display: grid;
            min-width: 100%;
        }
        
        #stepNumbers {
            display: grid;
            gap: 5px;
            padding-bottom: 5px;
            border-bottom: 1px solid #444;
        }

        #stepNumbers > div {
            text-align: center;
            color: #888;
        }

        .track-row {
            display: grid;
            gap: 5px;
            padding: 5px 0;
            align-items: center;
        }

        .track-label {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .step-button {
            width: 100%;
            aspect-ratio: 1 / 1;
            background-color: #444;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.1s;
        }

        .step-button.active {
            background-color: var(--track-color);
            box-shadow: 0 0 10px var(--track-color);
        }

        .step-button.playing {
            border: 2px solid #00ff80;
            box-shadow: 0 0 10px rgba(0,255,128,0.7), inset 0 0 5px rgba(255,255,255,0.5);
            animation: pulse-border 0.5s infinite alternate;
        }

        .step-button.active.playing {
            background-color: #e0e0e0;
            box-shadow: 0 0 15px var(--track-color), 0 0 25px var(--track-color);
        }

        .step-button.beat-1 {
            border-left: 2px solid #aaa;
        }

        .step-button.beat-1.playing {
            border-left: 2px solid #e0e0e0;
        }

        .volume-control {
            display: flex;
            align-items: center;
        }

        .volume-slider {
            -webkit-appearance: slider-vertical;
            writing-mode: bt-lr;
            width: 12px;
            height: 60px;
        }

        .volume-slider::-webkit-slider-thumb {
            width: 16px;
            height: 16px;
        }

        .preset-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            background-color: #333;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #444;
        }

        .category-tabs {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .category-tab {
            padding: 8px 15px;
            background-color: #444;
            color: #e0e0e0;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }

        .category-tab:hover {
            background-color: #555;
        }

        .category-tab.active {
            background-color: #00ff80;
            color: #1a1a1a;
            border-color: #00ff80;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            width: 100%;
        }
        
        .preset-btn {
            background-color: #444;
            color: #e0e0e0;
            border: 1px solid #00ff80;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .preset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 255, 128, 0.2);
        }
        
        .ai-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        
        .ai-controls button {
            background-color: #9b59b6;
            color: #1a1a1a;
            padding: 10px 20px;
            border-radius: 5px;
            border: none;
            font-family: 'Roboto Mono', monospace;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .ai-controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(155, 89, 182, 0.4);
        }
        
        #aiStatus {
            text-align: center;
            font-size: 1.2rem;
            height: 25px;
            margin-top: 10px;
            transition: opacity 1s;
        }

        .voice-export-controls {
            display: flex;
            justify-content: space-around;
            align-items: center;
            background-color: #333;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #444;
            flex-wrap: wrap;
            gap: 10px;
        }

        .voice-controls, .export-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .voice-controls button, .export-controls button {
            padding: 10px 20px;
            border-radius: 5px;
            border: none;
            font-family: 'Roboto Mono', monospace;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
        }

        #recordVoiceBtn {
            background-color: #e74c3c;
            color: #1a1a1a;
        }

        #recordVoiceBtn.recording {
            background-color: #ff0080;
            box-shadow: 0 0 15px #ff0080;
            animation: pulse-record 1.5s infinite;
        }

        #playVoiceBtn {
            background-color: #3498db;
            color: #1a1a1a;
        }

        #generateLyricsBtn {
            background-color: #9b59b6;
            color: #1a1a1a;
        }
        
        #exportMp3Btn {
            background-color: #f39c12;
            color: #1a1a1a;
        }

        #voiceStatus, #exportStatus {
            height: 20px;
            font-size: 0.9rem;
            text-align: center;
        }

        .info-bar {
            text-align: center;
            color: #888;
            font-size: 0.9rem;
            margin-top: 5px;
        }
        
        @keyframes pulse-record {
            0% { box-shadow: 0 0 5px #ff0080; }
            50% { box-shadow: 0 0 20px #ff0080; }
            100% { box-shadow: 0 0 5px #ff0080; }
        }

        @media (max-width: 768px) {
            .controls, .sliders, .voice-export-controls {
                flex-direction: column;
                align-items: stretch;
            }
            .volume-control {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PRODIGY BEAST SEQUENCER</h1>
        <div class="info-bar">
            A tribute to the iconic sounds of The Prodigy. Create your own breakbeats!
        </div>

        <div class="controls">
            <div class="transport">
                <button id="playBtn">▶ PLAY</button>
                <button id="stopBtn">⏹ STOP</button>
                <button id="clearBtn">🗑 CLEAR</button>
            </div>
            <div class="tempo-control">
                <label for="tempoSlider">TEMPO: <span id="tempoDisplay">140</span> BPM</label>
                <input type="range" id="tempoSlider" min="60" max="200" value="140">
            </div>
            <div class="length-control">
                <label for="sequenceLengthSelect">LENGTH:</label>
                <select id="sequenceLengthSelect">
                    <option value="8">8 STEPS</option>
                    <option value="16" selected>16 STEPS</option>
                    <option value="32">32 STEPS</option>
                    <option value="64">64 STEPS</option>
                </select>
            </div>
        </div>

        <div class="info-bar" id="sequenceInfo"></div>

        <div class="sliders">
            <div class="slider-group">
                <span>MASTER VOLUME</span>
                <input type="range" id="masterVolume" min="0" max="100" value="80">
            </div>
            <div class="slider-group">
                <span>FILTER FREQ</span>
                <input type="range" id="filterFreq" min="100" max="20000" value="20000">
            </div>
            <div class="slider-group">
                <span>DISTORTION</span>
                <input type="range" id="distortion" min="0" max="100" value="0">
            </div>
            <div class="slider-group">
                <span>REVERB MIX</span>
                <input type="range" id="reverb" min="0" max="100" value="50">
            </div>
            <div class="slider-group">
                <span>DELAY MIX</span>
                <input type="range" id="delay" min="0" max="100" value="0">
            </div>
        </div>

        <div class="grid-container">
            <div class="sequencer-grid">
                <div id="stepNumbers"></div>
                <div id="tracks"></div>
            </div>
        </div>
        
        <div class="preset-controls">
            <h2>BEAST PRESETS</h2>
            <div class="category-tabs" id="categoryTabs"></div>
            <div class="preset-grid" id="presetGrid"></div>
        </div>
        
        <div class="ai-controls">
            <button id="heartPattern">❤️ HEART PATTERN</button>
            <button id="evolvePattern">🧬 EVOLVE PATTERN</button>
            <button id="generateVariation">🎲 GENERATE VARIATION</button>
            <button id="smartFill">✨ SMART FILL</button>
        </div>
        <div id="aiStatus"></div>

        <div class="voice-export-controls">
            <div class="voice-controls">
                <h2>VOICE & AI LYRICS</h2>
                <button id="recordVoiceBtn">🎤 RECORD VOICE</button>
                <button id="playVoiceBtn" disabled>▶ PLAY VOICE</button>
                <button id="generateLyricsBtn" disabled>🤖 GENERATE LYRICS</button>
                <div id="voiceStatus"></div>
            </div>
            <div class="export-controls">
                <h2>EXPORT AUDIO</h2>
                <button id="exportMp3Btn">🎵 EXPORT AS WEBM</button>
                <div id="exportStatus"></div>
            </div>
        </div>
    </div>
    <script>
        // Audio Context and Variables
        let audioContext;
        let masterGain;
        let filterNode;
        let distortionNode;
        let reverbNode;
        let delayNode;
        // NEW: Add a gain node for the delay effect
        let delayGain; 
        let isPlaying = false;
        let currentStep = 0;
        let nextStepTime = 0;
        let lookAhead = 25;
        let scheduleAheadTime = 0.1;
        let tempo = 140;

        // Dynamic sequence length
        let sequenceLength = 16;

        // Voice Recording
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let recordedVoiceBlob = null;

        // Export functionality
        let exportRecorder = null;
        let exportDestination = null;

        // Track Configuration
        const tracks = [
            { name: 'KICK', color: '#ff0080', colorRgb: '255,0,128', volume: 0.9, type: 'kick' },
            { name: 'SNARE', color: '#00ff80', colorRgb: '0,255,128', volume: 0.7, type: 'snare' },
            { name: 'HI-HAT', color: '#0080ff', colorRgb: '0,128,255', volume: 0.5, type: 'hihat' },
            { name: 'OPEN HAT', color: '#ff8000', colorRgb: '255,128,0', volume: 0.4, type: 'openhat' },
            { name: 'BASS', color: '#8000ff', colorRgb: '128,0,255', volume: 0.8, type: 'bass' },
            { name: 'LEAD', color: '#ff0040', colorRgb: '255,0,64', volume: 0.6, type: 'lead' },
            { name: 'PERC', color: '#40ff00', colorRgb: '64,255,0', volume: 0.5, type: 'perc' },
            { name: 'FX', color: '#ff4000', colorRgb: '255,64,0', volume: 0.4, type: 'fx' }
        ];

        // Dynamic Pattern Storage
        let patterns = Array.from({length: tracks.length}, () => Array(sequenceLength).fill(false));
        let likedPatterns = [];
        let patternHistory = [];
        let aiPreferences = {
            density: 0.6,
            kickPattern: 'basic',
            style: 'prodigy'
        };

        // Sample Pack Categories
        const presetCategories = {
            prodigy: {
                name: "🔥 PRODIGY PACK",
                presets: {
                    firestarter: {
                        name: "Firestarter",
                        pattern: [
                            [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
                            [0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,1],
                            [1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],
                            [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
                            [1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0],
                            [0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1],
                            [1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0],
                            [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]
                        ]
                    },
                    breathe: {
                        name: "Breathe",
                        pattern: [
                            [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
                            [0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0],
                            [0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0],
                            [0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1],
                            [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                            [0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0],
                            [0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0],
                            [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]
                        ]
                    },
                    smackMyBitch: {
                        name: "Smack My Bitch Up",
                        pattern: [
                            [1,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0],
                            [0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1],
                            [1,1,1,0,1,1,0,1,1,1,1,0,1,1,0,1],
                            [0,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0],
                            [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
                            [0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1],
                            [1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0],
                            [0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1]
                        ]
                    },
                    voodoo: {
                        name: "Voodoo People",
                        pattern: [
                            [1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0],
                            [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
                            [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
                            [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],
                            [1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0],
                            [0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0],
                            [1,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1],
                            [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0]
                        ]
                    },
                    outOfSpace: {
                        name: "Out of Space",
                        pattern: [
                            [1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0],
                            [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
                            [1,1,0,1,1,0,1,1,1,1,0,1,1,0,1,1],
                            [0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0],
                            [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                            [0,1,0,0,1,0,1,0,0,1,0,0,1,0,1,0],
                            [0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1],
                            [1,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0]
                        ]
                    }
                }
            },
            dnb: {
                name: "🥁 DRUM & BASS EXTENDED",
                presets: {
                    amen: {
                        name: "Amen Break",
                        pattern: [
                            [1,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0],
                            [0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,1],
                            [1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1],
                            [0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0],
                            [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                            [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
                            [1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0],
                            [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1]
                        ]
                    },
                    neurofunk: {
                        name: "Neurofunk",
                        pattern: [
                            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],
                            [0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0],
                            [1,1,0,1,1,0,1,1,1,1,0,1,1,0,1,1],
                            [0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0],
                            [1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0],
                            [0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0],
                            [0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1],
                            [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]
                        ]
                    },
                    liquid: {
                        name: "Liquid D&B",
                        pattern: [
                            [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                            [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
                            [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
                            [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],
                            [1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0],
                            [0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0],
                            [0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1],
                            [0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0]
                        ]
                    },
                    jumpUp: {
                        name: "Jump Up",
                        pattern: [
                            [1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0],
                            [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
                            [1,1,1,0,1,1,0,1,1,1,1,0,1,1,0,1],
                            [0,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0],
                            [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                            [0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1],
                            [0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0],
                            [1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1]
                        ]
                    },
                    hardstep: {
                        name: "Hardstep",
                        pattern: [
                            [1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0],
                            [0,0,0,1,1,0,0,1,0,0,0,1,1,0,0,1],
                            [1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1],
                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                            [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
                            [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
                            [1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1],
                            [0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1]
                        ]
                    },
                    darkstep: {
                        name: "Darkstep",
                        pattern: [
                            [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
                            [0,0,1,0,1,0,0,1,0,1,0,0,1,0,1,0],
                            [1,1,0,1,1,0,1,1,1,1,0,1,1,0,1,1],
                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                            [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                            [0,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0],
                            [0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1],
                            [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]
                        ]
                    }
                }
            },
            bigbeat: {
                name: "💥 BIG BEAT",
                presets: {
                    blockRocker: {
                        name: "Block Rockin' Beats",
                        pattern: [
                            [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
                            [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
                            [1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1],
                            [0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1],
                            [1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0],
                            [0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1],
                            [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
                            [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]
                        ]
                    },
                    fatboy: {
                        name: "Fatboy Style",
                        pattern: [
                            [1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0],
                            [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
                            [1,1,0,1,1,0,1,1,1,1,0,1,1,0,1,1],
                            [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],
                            [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                            [0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1],
                            [0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1],
                            [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]
                        ]
                    },
                    crystal: {
                        name: "Crystal Method",
                        pattern: [
                            [1,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0],
                            [0,0,0,1,1,0,0,1,0,0,0,1,1,0,0,1],
                            [1,1,1,0,1,1,0,1,1,1,1,0,1,1,0,1],
                            [0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0],
                            [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                            [0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0],
                            [0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0],
                            [0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0]
                        ]
                    }
                }
            },
            hardcore: {
                name: "⚡ HARDCORE",
                presets: {
                    gabber: {
                        name: "Gabber",
                        pattern: [
                            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                            [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
                            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                            [0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1],
                            [1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1],
                            [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
                            [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
                            [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]
                        ]
                    },
                    speedcore: {
                        name: "Speedcore",
                        pattern: [
                            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                            [0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0],
                            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                            [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
                            [1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1],
                            [0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0],
                            [1,1,0,1,1,0,1,1,1,1,0,1,1,0,1,1],
                            [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0]
                        ]
                    },
                    terror: {
                        name: "Terror",
                        pattern: [
                            [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1],
                            [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
                            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                            [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
                            [1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1],
                            [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
                            [0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1],
                            [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]
                        ]
                    }
                }
            },
            experimental: {
                name: "🧪 EXPERIMENTAL",
                presets: {
                    glitch: {
                        name: "Glitch",
                        pattern: [
                            [1,0,1,0,0,1,0,0,1,0,0,0,1,1,0,0],
                            [0,1,0,0,1,0,1,0,0,0,0,1,0,0,1,0],
                            [1,0,0,1,0,1,0,1,0,0,1,0,1,0,0,1],
                            [0,0,1,0,0,0,0,1,0,1,0,0,0,0,1,0],
                            [1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1],
                            [0,1,0,1,0,0,0,0,1,0,1,0,0,1,0,0],
                            [0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1],
                            [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0]
                        ]
                    },
                    idm: {
                        name: "IDM",
                        pattern: [
                            [1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0],
                            [0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,0],
                            [0,1,0,0,1,0,1,0,0,1,0,0,1,0,1,0],
                            [0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0],
                            [1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1],
                            [0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0],
                            [0,1,0,1,0,0,1,0,0,1,0,1,0,0,1,0],
                            [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]
                        ]
                    },
                    ambient: {
                        name: "Ambient",
                        pattern: [
                            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                            [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                            [0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0],
                            [0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0],
                            [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                            [0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0],
                            [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
                            [0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0]
                        ]
                    }
                }
            }
        };

        let currentCategory = 'prodigy';

        // Dynamic sequence length functions
        function updateSequenceLength(newLength) {
            const oldLength = sequenceLength;
            sequenceLength = parseInt(newLength);
            
            // Update patterns array
            patterns = patterns.map(track => {
                if (sequenceLength > oldLength) {
                    // Extend with false values
                    return [...track, ...Array(sequenceLength - oldLength).fill(false)];
                } else {
                    // Truncate
                    return track.slice(0, sequenceLength);
                }
            });
            
            // Update UI
            generateUI();
            updatePatternDisplay();
            
            // Update sequence info
            updateSequenceInfo();
            
            // Reset playback
            if (isPlaying) {
                pauseSequencer();
            }
            currentStep = 0;
            
            showAIStatus(`🔄 Sequence length changed to ${sequenceLength} steps!`, '#00ff80');
        }

        function updateSequenceInfo() {
            const info = document.getElementById('sequenceInfo');
            const bars = sequenceLength / 4;
            const time = (60 / tempo) * bars * 4; // Time in seconds (one cycle)
            info.textContent = `${sequenceLength}-Step Beast Mode (${bars} bars, ${time.toFixed(1)}s @ ${tempo} BPM)`;
        }

        function getBeatClass(step) {
            const beatInBar = (step % 4) + 1;
            return `beat-${beatInBar}`;
        }

        // Initialize Audio with effects chain
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create effects chain
                masterGain = audioContext.createGain();
                filterNode = audioContext.createBiquadFilter();
                distortionNode = audioContext.createWaveShaper();
                // We'll create the reverb node and its impulse response later
                reverbNode = audioContext.createConvolver();
                delayNode = audioContext.createDelay();
                // NEW: Create a separate gain node for the delay feedback loop
                const feedbackGain = audioContext.createGain();
                // NEW: Create a gain node for the delayed signal
                delayGain = audioContext.createGain();

                // Setup filter
                filterNode.type = 'lowpass';
                filterNode.frequency.value = 20000;
                filterNode.Q.value = 1;
                
                // Setup distortion
                distortionNode.curve = makeDistortionCurve(0);
                distortionNode.oversample = '4x';

                // Setup delay
                // NEW: Delay time is a constant, feedback and gain are variable
                delayNode.delayTime.value = 0.25; // Quarter note delay
                feedbackGain.gain.value = 0.5; // Fixed feedback amount
                delayGain.gain.value = 0; // Starts at 0, controlled by slider

                // NEW: Corrected effects chain
                // The signal flow should be:
                // SOURCE -> FILTER -> DISTORTION -> REVERB -> DELAY (wet signal) -> MASTER GAIN
                // and a parallel path for the dry signal:
                // SOURCE -> FILTER -> DISTORTION -> MASTER GAIN
                // and a feedback loop for the delay:
                // DELAY -> FEEDBACK GAIN -> DELAY

                // Source connects to all effects
                // Individual sound generators will connect here
                
                // Connect the effects in series for the main signal path
                filterNode.connect(distortionNode);
                distortionNode.connect(reverbNode);

                // Reverb output is the main signal. Connect it to the master gain and the delay input.
                reverbNode.connect(masterGain);
                reverbNode.connect(delayNode);

                // Set up the delay feedback loop.
                delayNode.connect(feedbackGain);
                feedbackGain.connect(delayNode);
                // The delayed signal (wet) is mixed back into the main signal at the master gain.
                delayNode.connect(delayGain);
                delayGain.connect(masterGain);
                
                // Initialize Reverb impulse response
                createReverbImpulse(reverbNode);

                masterGain.gain.value = 0.8;
                
                // Setup for recording export
                exportDestination = audioContext.createMediaStreamDestination();
                masterGain.connect(exportDestination);
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        // NEW: Function to create a simple, synthetic reverb impulse response
        function createReverbImpulse(convolverNode) {
            const duration = 2.0; // seconds
            const decay = 1.0;
            const sampleRate = convolverNode.context.sampleRate;
            const length = sampleRate * duration;
            const impulse = convolverNode.context.createBuffer(2, length, sampleRate);
            const impulseL = impulse.getChannelData(0);
            const impulseR = impulse.getChannelData(1);

            for (let i = 0; i < length; i++) {
                const n = i;
                let x = Math.pow(1 - n / length, decay);
                impulseL[i] = (Math.random() * 2 - 1) * x * 0.5;
                impulseR[i] = (Math.random() * 2 - 1) * x * 0.5;
            }
            convolverNode.buffer = impulse;
        }

        // Distortion curve generator
        function makeDistortionCurve(amount) {
            const samples = 44100;
            const curve = new Float32Array(samples);
            const deg = Math.PI / 180;
            
            for (let i = 0; i < samples; i++) {
                const x = (i * 2) / samples - 1;
                curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
            }
            
            return curve;
        }

        // Voice Recording Functions
        async function startVoiceRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };
                
                mediaRecorder.onstop = () => {
                    recordedVoiceBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    document.getElementById('playVoiceBtn').disabled = false;
                    document.getElementById('generateLyricsBtn').disabled = false;
                    showVoiceStatus('🎤 Voice sample recorded! Ready for AI lyrics.', '#00ff80');
                };
                
                mediaRecorder.start();
                isRecording = true;
                
                document.getElementById('recordVoiceBtn').classList.add('recording');
                document.getElementById('recordVoiceBtn').textContent = '⏹ STOP RECORDING';
                showVoiceStatus('🔴 Recording voice... Speak now!', '#ff0080');
                
            } catch (error) {
                showVoiceStatus('❌ Microphone access denied or not available', '#ff4757');
                console.error('Error accessing microphone:', error);
            }
        }

        function stopVoiceRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                
                document.getElementById('recordVoiceBtn').classList.remove('recording');
                document.getElementById('recordVoiceBtn').textContent = '🎤 RECORD VOICE';
                
                // Stop all tracks
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }
        }

        function playVoiceSample() {
            if (recordedVoiceBlob) {
                const audio = new Audio(URL.createObjectURL(recordedVoiceBlob));
                audio.play();
                showVoiceStatus('▶ Playing voice sample...', '#00ff80');
            }
        }

        async function generateLyrics() {
            if (!recordedVoiceBlob) {
                showVoiceStatus('❌ No voice sample recorded', '#ff4757');
                return;
            }
            
            showVoiceStatus('🤖 Analyzing voice for AI lyrics...', '#9b59b6');
            
            try {
                // Create a File object from the blob
                const file = new File([recordedVoiceBlob], 'voice_sample.wav', { type: 'audio/wav' });
                
                if (window.Poe && window.Poe.sendUserMessage) {
                    // Send to AI for lyric generation
                    await window.Poe.sendUserMessage(
                        "@Claude-Sonnet-4 Analyze this voice sample and generate aggressive, Prodigy-style lyrics with punch lines and attitude. Focus on electronic music themes, rebellion, and energy. Provide 8-16 short, punchy lines that would work with breakbeats and electronic music.",
                        {
                            attachments: [file],
                            handler: "lyrics-handler",
                            stream: true,
                            openChat: false
                        }
                    );
                } else {
                    // Fallback if Poe API not available
                    generateFallbackLyrics();
                }
                
            } catch (error) {
                console.error('Error generating lyrics:', error);
                generateFallbackLyrics();
            }
        }

        function generateFallbackLyrics() {
            const fallbackLyrics = [
                "🔥 FIRESTARTER BEATS 🔥",
                "Break the system, feel the bass",
                "Electronic warrior in cyberspace", 
                "Pump the volume, lose control",
                "Digital rebel, rock and roll",
                "",
                "💥 PUNCH LINES 💥",
                "Smack the beat, break the chain",
                "Prodigy style, feel the pain",
                "Out of space, out of mind",
                "Leave the ordinary world behind",
                "",
                "⚡ ENERGY SURGE ⚡",
                "Breathe the rhythm, taste the sound",
                "Underground king, electronically crowned"
            ];
            
            displayGeneratedLyrics(fallbackLyrics.join('\n'));
        }

        function displayGeneratedLyrics(lyrics) {
            // Create modal dialog for lyrics
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0,0,0,0.8)';
            modal.style.display = 'flex';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            modal.style.zIndex = '1000';
            
            modal.innerHTML = `
                <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%); 
                           border: 2px solid #00ff80; border-radius: 15px; padding: 30px; 
                           max-width: 600px; width: 90%; max-height: 80%; overflow-y: auto;">
                    <h3 style="color: #00ff80; text-align: center; margin-bottom: 20px; font-size: 24px;">
                        🎤 AI GENERATED LYRICS 🎤
                    </h3>
                    <div style="background: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px; 
                               color: white; font-family: monospace; line-height: 1.6; white-space: pre-wrap;">
                        ${lyrics}
                    </div>
                    <div style="text-align: center; margin-top: 20px;">
                        <button onclick="this.closest('.fixed, [style*=position\\ \\:fixed]').remove()" 
                                style="background: linear-gradient(45deg, #00ff80, #00cc66); 
                                       color: black; padding: 12px 24px; border: none; 
                                       border-radius: 8px; font-weight: bold; cursor: pointer;">
                            CLOSE
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            showVoiceStatus('🎯 AI lyrics generated! Check the popup.', '#00ff80');
        }

        // MP3 Export Function
        async function exportToMP3() {
            if (!audioContext) {
                showExportStatus('❌ Start playing first to enable export', '#ff4757');
                return;
            }
            
            showExportStatus('🎵 Recording track for export...', '#ff8000');
            
            try {
                // Create a new media recorder for export
                exportRecorder = new MediaRecorder(exportDestination.stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });
                
                const exportChunks = [];
                
                exportRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        exportChunks.push(event.data);
                    }
                };
                
                exportRecorder.onstop = () => {
                    const blob = new Blob(exportChunks, { type: 'audio/webm' });
                    const url = URL.createObjectURL(blob);
                    
                    // Create download link
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `prodigy_beast_${sequenceLength}step_loop_${Date.now()}.webm`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    showExportStatus('✅ Track exported successfully!', '#00ff80');
                    URL.revokeObjectURL(url);
                };
                
                // Start recording
                exportRecorder.start();
                
                // Record for the length of the sequence
                const barsToRecord = Math.max(1, Math.ceil(sequenceLength / 16)); // At least 1 full cycle
                const recordingTime = (60 / tempo) * sequenceLength * barsToRecord * 1000; // milliseconds
                
                setTimeout(() => {
                    if (exportRecorder && exportRecorder.state === 'recording') {
                        exportRecorder.stop();
                    }
                }, recordingTime);
                
                showExportStatus(`🔄 Recording ${Math.round(recordingTime/1000)}s loop...`, '#ff8000');
                
            } catch (error) {
                console.error('Export error:', error);
                showExportStatus('❌ Export failed. Try a different browser.', '#ff4757');
            }
        }

        // Register handler for lyrics generation
        if (window.Poe && window.Poe.registerHandler) {
            window.Poe.registerHandler("lyrics-handler", (result, context) => {
                const msg = result.responses[0];
                
                if (msg.status === "error") {
                    showVoiceStatus("❌ AI lyrics generation failed", '#ff4757');
                    generateFallbackLyrics();
                } else if (msg.status === "complete") {
                    displayGeneratedLyrics(msg.content);
                } else if (msg.status === "incomplete") {
                    showVoiceStatus("🤖 AI is generating lyrics...", '#9b59b6');
                }
            });
        }

        // Status display functions
        function showVoiceStatus(message, color) {
            const statusEl = document.getElementById('voiceStatus');
            statusEl.textContent = message;
            statusEl.style.color = color;
        }

        function showExportStatus(message, color) {
            const statusEl = document.getElementById('exportStatus');
            statusEl.textContent = message;
            statusEl.style.color = color;
        }

        // Enhanced sound generation with effects
        function createKick(when, volume) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const kickFilter = audioContext.createBiquadFilter();
            
            osc.frequency.setValueAtTime(60, when);
            osc.frequency.exponentialRampToValueAtTime(0.1, when + 0.5);
            
            kickFilter.type = 'lowpass';
            kickFilter.frequency.setValueAtTime(200, when);
            kickFilter.Q.setValueAtTime(1, when);
            
            gain.gain.setValueAtTime(volume * 1.2, when);
            gain.gain.exponentialRampToValueAtTime(0.001, when + 0.5);
            
            osc.connect(kickFilter);
            kickFilter.connect(gain);
            // NEW: Connect the gain to the main effects chain
            gain.connect(filterNode);
            
            osc.start(when);
            osc.stop(when + 0.5);
        }

        function createSnare(when, volume) {
            const bufferSize = audioContext.sampleRate * 0.2;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                output[i] = (Math.random() * 2 - 1) * 0.4;
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;
            
            const noiseGain = audioContext.createGain();
            const noiseFilter = audioContext.createBiquadFilter();
            
            noiseFilter.type = 'highpass';
            noiseFilter.frequency.setValueAtTime(1000, when);
            
            noiseGain.gain.setValueAtTime(volume * 0.6, when);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, when + 0.2);
            
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            // NEW: Connect the gain to the main effects chain
            noiseGain.connect(filterNode);
            
            noise.start(when);

            const osc = audioContext.createOscillator();
            const oscGain = audioContext.createGain();
            
            osc.frequency.setValueAtTime(200, when);
            osc.frequency.exponentialRampToValueAtTime(100, when + 0.1);
            
            oscGain.gain.setValueAtTime(volume * 0.4, when);
            oscGain.gain.exponentialRampToValueAtTime(0.001, when + 0.1);
            
            osc.connect(oscGain);
            // NEW: Connect the gain to the main effects chain
            oscGain.connect(filterNode);
            
            osc.start(when);
            osc.stop(when + 0.1);
        }

        function createHiHat(when, volume, open = false) {
            const bufferSize = audioContext.sampleRate * (open ? 0.3 : 0.1);
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                output[i] = (Math.random() * 2 - 1) * 0.1;
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;
            
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(open ? 6000 : 10000, when);
            filter.Q.setValueAtTime(1, when);
            
            gain.gain.setValueAtTime(volume, when);
            gain.gain.exponentialRampToValueAtTime(0.001, when + (open ? 0.3 : 0.1));
            
            noise.connect(filter);
            filter.connect(gain);
            // NEW: Connect the gain to the main effects chain
            gain.connect(filterNode);
            
            noise.start(when);
        }

        function createBass(when, volume) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const bassFilter = audioContext.createBiquadFilter();
            
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(80, when);
            
            bassFilter.type = 'lowpass';
            bassFilter.frequency.setValueAtTime(800, when);
            bassFilter.frequency.exponentialRampToValueAtTime(200, when + 0.3);
            bassFilter.Q.setValueAtTime(15, when);
            
            gain.gain.setValueAtTime(volume * 1.0, when);
            gain.gain.exponentialRampToValueAtTime(0.001, when + 0.3);
            
            osc.connect(bassFilter);
            bassFilter.connect(gain);
            // NEW: Connect the gain to the main effects chain
            gain.connect(filterNode);
            
            osc.start(when);
            osc.stop(when + 0.3);
        }

        function createLead(when, volume) {
            const osc1 = audioContext.createOscillator();
            const osc2 = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const leadFilter = audioContext.createBiquadFilter();
            
            osc1.type = 'square';
            osc2.type = 'square';
            osc1.frequency.setValueAtTime(440, when);
            osc2.frequency.setValueAtTime(443, when);
            
            leadFilter.type = 'lowpass';
            leadFilter.frequency.setValueAtTime(2000, when);
            leadFilter.Q.setValueAtTime(10, when);
            
            gain.gain.setValueAtTime(volume * 0.6, when);
            gain.gain.exponentialRampToValueAtTime(0.001, when + 0.2);
            
            osc1.connect(leadFilter);
            osc2.connect(leadFilter);
            leadFilter.connect(gain);
            // NEW: Connect the gain to the main effects chain
            gain.connect(filterNode);
            
            osc1.start(when);
            osc2.start(when);
            osc1.stop(when + 0.2);
            osc2.stop(when + 0.2);
        }

        function createPerc(when, volume) {
            const osc1 = audioContext.createOscillator();
            const osc2 = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const percFilter = audioContext.createBiquadFilter();
            
            osc1.frequency.setValueAtTime(800, when);
            osc2.frequency.setValueAtTime(1200, when);
            osc1.frequency.exponentialRampToValueAtTime(400, when + 0.1);
            osc2.frequency.exponentialRampToValueAtTime(600, when + 0.1);
            
            percFilter.type = 'bandpass';
            percFilter.frequency.setValueAtTime(1000, when);
            percFilter.Q.setValueAtTime(5, when);
            
            gain.gain.setValueAtTime(volume * 0.7, when);
            gain.gain.exponentialRampToValueAtTime(0.001, when + 0.1);
            
            osc1.connect(percFilter);
            osc2.connect(percFilter);
            percFilter.connect(gain);
            // NEW: Connect the gain to the main effects chain
            gain.connect(filterNode);
            
            osc1.start(when);
            osc2.start(when);
            osc1.stop(when + 0.1);
            osc2.stop(when + 0.1);
        }

        function createFX(when, volume) {
            const bufferSize = audioContext.sampleRate * 0.5;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                output[i] = (Math.random() * 2 - 1) * 0.1;
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;
            
            const gain = audioContext.createGain();
            const fxFilter = audioContext.createBiquadFilter();
            
            fxFilter.type = 'bandpass';
            fxFilter.frequency.setValueAtTime(2000, when);
            fxFilter.frequency.exponentialRampToValueAtTime(500, when + 0.5);
            fxFilter.Q.setValueAtTime(20, when);
            
            gain.gain.setValueAtTime(volume * 0.4, when);
            gain.gain.exponentialRampToValueAtTime(0.001, when + 0.5);
            
            noise.connect(fxFilter);
            fxFilter.connect(gain);
            // NEW: Connect the gain to the main effects chain
            gain.connect(filterNode);
            
            noise.start(when);
        }

        function playSound(trackType, when, volume) {
            switch(trackType) {
                case 'kick': createKick(when, volume); break;
                case 'snare': createSnare(when, volume); break;
                case 'hihat': createHiHat(when, volume, false); break;
                case 'openhat': createHiHat(when, volume, true); break;
                case 'bass': createBass(when, volume); break;
                case 'lead': createLead(when, volume); break;
                case 'perc': createPerc(when, volume); break;
                case 'fx': createFX(when, volume); break;
            }
        }

        function generateUI() {
            // Generate step numbers
            const stepNumbers = document.getElementById('stepNumbers');
            const gridCols = `100px 60px repeat(${sequenceLength}, 1fr)`;
            stepNumbers.style.gridTemplateColumns = gridCols;
            
            stepNumbers.innerHTML = `
                <div></div>
                <div>VOL</div>
                ${Array.from({length: sequenceLength}, (_, i) => 
                    `<div class="step-number">${i + 1}</div>`
                ).join('')}
            `;
            
            // Generate tracks
            const tracksContainer = document.getElementById('tracks');
            
            tracksContainer.innerHTML = tracks.map((track, trackIndex) => `
                <div class="track-row" style="grid-template-columns: ${gridCols}">
                    <div class="track-label" style="color: ${track.color}">
                        ${track.name}
                    </div>
                    <div class="volume-control">
                        <input type="range" min="0" max="100" value="${Math.round(track.volume * 100)}" 
                               class="volume-slider" data-track="${trackIndex}">
                    </div>
                    ${Array.from({length: sequenceLength}, (_, stepIndex) => `
                        <button class="step-button ${getBeatClass(stepIndex)}" 
                                data-track="${trackIndex}" 
                                data-step="${stepIndex}"
                                style="--track-color: ${track.color}; --track-color-dark: ${track.color}dd; --track-color-rgb: ${track.colorRgb}"></button>
                    `).join('')}
                </div>
            `).join('');
        }

        function generateCategoryTabs() {
            const categoryTabs = document.getElementById('categoryTabs');
            
            categoryTabs.innerHTML = Object.keys(presetCategories).map(categoryKey => `
                <button class="category-tab ${categoryKey === currentCategory ? 'active' : ''}" 
                        data-category="${categoryKey}">
                    ${presetCategories[categoryKey].name}
                </button>
            `).join('');
        }

        function generatePresetGrid() {
            const presetGrid = document.getElementById('presetGrid');
            const categoryData = presetCategories[currentCategory];
            
            if (!categoryData) return;
            
            presetGrid.innerHTML = Object.keys(categoryData.presets).map(presetKey => `
                <button class="preset-btn" data-preset="${presetKey}" data-category="${currentCategory}">
                    ${categoryData.presets[presetKey].name}
                </button>
            `).join('');
        }

        function nextNote() {
            const secondsPerBeat = 60.0 / tempo;
            nextStepTime += 0.25 * secondsPerBeat;
            currentStep++;
            if (currentStep === sequenceLength) {
                currentStep = 0;
            }
        }

        function scheduleNote(stepNumber, time) {
            setTimeout(() => {
                updateStepIndicators(stepNumber);
            }, (time - audioContext.currentTime) * 1000);

            tracks.forEach((track, trackIndex) => {
                if (patterns[trackIndex][stepNumber]) {
                    playSound(track.type, time, track.volume);
                }
            });
        }

        function scheduler() {
            while (nextStepTime < audioContext.currentTime + scheduleAheadTime) {
                scheduleNote(currentStep, nextStepTime);
                nextNote();
            }
            if (isPlaying) {
                setTimeout(scheduler, lookAhead);
            }
        }

        function updateStepIndicators(step) {
            document.querySelectorAll('.step-button').forEach(btn => {
                btn.classList.remove('playing');
            });
            
            document.querySelectorAll(`[data-step="${step}"]`).forEach(btn => {
                btn.classList.add('playing');
            });
        }

        function startSequencer() {
            initAudio();
            isPlaying = true;
            currentStep = 0;
            nextStepTime = audioContext.currentTime;
            
            const playBtn = document.getElementById('playBtn');
            playBtn.innerHTML = '⏸ PAUSE';
            playBtn.classList.add('playing');
            
            scheduler();
        }

        function pauseSequencer() {
            isPlaying = false;
            const playBtn = document.getElementById('playBtn');
            playBtn.innerHTML = '▶ PLAY';
            playBtn.classList.remove('playing');
            
            document.querySelectorAll('.step-button').forEach(btn => {
                btn.classList.remove('playing');
            });
        }

        function stopSequencer() {
            pauseSequencer();
            currentStep = 0;
        }

        function clearPattern() {
            patterns = Array.from({length: tracks.length}, () => Array(sequenceLength).fill(false));
            updatePatternDisplay();
        }

        function updatePatternDisplay() {
            document.querySelectorAll('.step-button').forEach(btn => {
                const track = parseInt(btn.dataset.track);
                const step = parseInt(btn.dataset.step);
                if (patterns[track] && patterns[track][step] !== undefined) {
                    btn.classList.toggle('active', patterns[track][step]);
                }
            });
        }

        function loadPreset(presetKey, categoryKey = currentCategory) {
            const categoryData = presetCategories[categoryKey];
            if (categoryData && categoryData.presets[presetKey]) {
                const presetPattern = categoryData.presets[presetKey].pattern;
                
                // Adapt preset to current sequence length
                patterns = presetPattern.map(track => {
                    if (sequenceLength <= track.length) {
                        // Truncate
                        return track.slice(0, sequenceLength);
                    } else {
                        // Extend by repeating pattern
                        const extended = [...track];
                        while (extended.length < sequenceLength) {
                            const remaining = sequenceLength - extended.length;
                            const toAdd = Math.min(remaining, track.length);
                            extended.push(...track.slice(0, toAdd));
                        }
                        return extended;
                    }
                });
                
                updatePatternDisplay();
            }
        }

        function switchCategory(categoryKey) {
            currentCategory = categoryKey;
            
            // Update active tab
            document.querySelectorAll('.category-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.category === categoryKey);
            });
            
            generatePresetGrid();
        }

        // AI Functions (enhanced for dynamic lengths)
        function heartCurrentPattern() {
            const currentPattern = patterns.map(track => [...track]);
            likedPatterns.push({
                pattern: currentPattern,
                timestamp: Date.now(),
                density: calculatePatternDensity(currentPattern),
                style: analyzePatternStyle(currentPattern),
                length: sequenceLength
            });
            
            updateAIPreferences(currentPattern);
            showAIStatus(`❤️ ${sequenceLength}-STEP BEAST PATTERN HEARTED! (${likedPatterns.length} total)`, '#e74c3c');
        }

        function calculatePatternDensity(pattern) {
            let totalSteps = 0;
            let activeSteps = 0;
            
            pattern.forEach(track => {
                track.forEach(step => {
                    totalSteps++;
                    if (step) activeSteps++;
                });
            });
            
            return activeSteps / totalSteps;
        }

        function analyzePatternStyle(pattern) {
            const kickPattern = pattern[0];
            const kickCount = kickPattern.filter(step => step).length;
            
            if (kickCount >= sequenceLength * 0.75) return 'hardcore';
            if (kickCount >= sequenceLength * 0.5) return 'prodigy';
            if (kickPattern[0] && kickPattern[4] && kickPattern[8] && kickPattern[12]) return 'four-on-floor';
            if (kickCount <= 2) return 'minimal';
            return 'breakbeat';
        }

        function updateAIPreferences(pattern) {
            const density = calculatePatternDensity(pattern);
            const style = analyzePatternStyle(pattern);
            
            aiPreferences.density = (aiPreferences.density * 0.7) + (density * 0.3);
            aiPreferences.style = style;
            aiPreferences.kickPattern = analyzeKickPattern(pattern[0]);
        }

        function analyzeKickPattern(kickTrack) {
            if (kickTrack[0] && kickTrack[4] && kickTrack[8] && kickTrack[12]) return 'four-on-floor';
            if (kickTrack.filter(s => s).length <= 2) return 'minimal';
            if (kickTrack.filter(s => s).length >= sequenceLength * 0.5) return 'aggressive';
            return 'syncopated';
        }

        function evolveCurrentPattern() {
            if (likedPatterns.length === 0) {
                showAIStatus('❤️ Heart some BEAST patterns first!', '#f39c12');
                return;
            }
            
            patternHistory.push(patterns.map(track => [...track]));
            
            const newPattern = generateEvolvedPattern();
            patterns = newPattern;
            updatePatternDisplay();
            
            showAIStatus('🧬 BEAST PATTERN EVOLVED!', '#9b59b6');
        }

        function generateEvolvedPattern() {
            // Find a liked pattern with similar length or adapt one
            let basePattern = likedPatterns[Math.floor(Math.random() * likedPatterns.length)].pattern;
            
            // Adapt to current sequence length
            if (basePattern[0].length !== sequenceLength) {
                basePattern = basePattern.map(track => {
                    if (sequenceLength <= track.length) {
                        return track.slice(0, sequenceLength);
                    } else {
                        const extended = [...track];
                        while (extended.length < sequenceLength) {
                            const remaining = sequenceLength - extended.length;
                            const toAdd = Math.min(remaining, track.length);
                            extended.push(...track.slice(0, toAdd));
                        }
                        return extended;
                    }
                });
            }
            
            const newPattern = basePattern.map(track => [...track]);
            
            tracks.forEach((track, trackIndex) => {
                for (let step = 0; step < sequenceLength; step++) {
                    let mutationChance = 0.4;
                    
                    if (aiPreferences.density > 0.7) mutationChance += 0.2;
                    if (aiPreferences.style === 'prodigy') mutationChance += 0.1;
                    
                    if (Math.random() < mutationChance) {
                        if (trackIndex === 0) {
                            newPattern[trackIndex][step] = generateSmartKick(step);
                        } else if (trackIndex === 1) {
                            newPattern[trackIndex][step] = generateSmartSnare(step, newPattern[0]);
                        } else if (trackIndex === 2) {
                            newPattern[trackIndex][step] = generateSmartHiHat(step, newPattern[0]);
                        } else {
                            newPattern[trackIndex][step] = Math.random() < aiPreferences.density;
                        }
                    }
                }
            });
            
            return newPattern;
        }

        function generateSmartKick(step) {
            if (aiPreferences.kickPattern === 'aggressive') {
                return Math.random() < 0.7;
            } else if (aiPreferences.kickPattern === 'four-on-floor') {
                return step % 4 === 0;
            } else if (aiPreferences.kickPattern === 'minimal') {
                return step === 0 || (step === Math.floor(sequenceLength/2) && Math.random() < 0.7);
            } else {
                if (step % 4 === 0) return Math.random() < 0.9;
                if (step % 4 === 2) return Math.random() < 0.4;
                return Math.random() < 0.2;
            }
        }

        function generateSmartSnare(step, kickPattern) {
            if (kickPattern[step]) return false;
            if (step === 4 || step === 12) return Math.random() < 0.9;
            if (step === 6 || step === 14) return Math.random() < 0.5;
            if (aiPreferences.style === 'prodigy') return Math.random() < 0.3;
            return Math.random() < 0.1;
        }

        function generateSmartHiHat(step, kickPattern) {
            const baseProbability = aiPreferences.density;
            if (aiPreferences.style === 'prodigy') {
                return Math.random() < baseProbability * 1.2;
            }
            if (step % 2 === 1) return Math.random() < baseProbability;
            return Math.random() < baseProbability * 0.6;
        }

        function generateVariation() {
            patternHistory.push(patterns.map(track => [...track]));
            
            const newPattern = patterns.map(track => [...track]);
            
            const tracksToVary = Math.floor(Math.random() * 3) + 2;
            const selectedTracks = [];
            
            while (selectedTracks.length < tracksToVary) {
                const trackIndex = Math.floor(Math.random() * tracks.length);
                if (!selectedTracks.includes(trackIndex)) {
                    selectedTracks.push(trackIndex);
                }
            }
            
            selectedTracks.forEach(trackIndex => {
                for (let step = 0; step < sequenceLength; step++) {
                    if (Math.random() < 0.3) {
                        newPattern[trackIndex][step] = !newPattern[trackIndex][step];
                    }
                }
            });
            
            patterns = newPattern;
            updatePatternDisplay();
            showAIStatus('🎲 BEAST VARIATION GENERATED!', '#3498db');
        }

        function smartFill() {
            patternHistory.push(patterns.map(track => [...track]));
            
            tracks.forEach((track, trackIndex) => {
                const currentSteps = patterns[trackIndex].filter(step => step).length;
                const targetDensity = Math.min(aiPreferences.density * sequenceLength, sequenceLength * 0.75);
                
                if (currentSteps < targetDensity) {
                    const stepsToAdd = Math.floor(targetDensity - currentSteps);
                    let added = 0;
                    
                    for (let step = 0; step < sequenceLength && added < stepsToAdd; step++) {
                        if (!patterns[trackIndex][step]) {
                            let shouldAdd = false;
                            
                            if (trackIndex === 0) {
                                shouldAdd = generateSmartKick(step);
                            } else if (trackIndex === 1) {
                                shouldAdd = generateSmartSnare(step, patterns[0]);
                            } else if (trackIndex === 2) {
                                shouldAdd = generateSmartHiHat(step, patterns[0]);
                            } else {
                                shouldAdd = Math.random() < 0.5;
                            }
                            
                            if (shouldAdd) {
                                patterns[trackIndex][step] = true;
                                added++;
                            }
                        }
                    }
                }
            });
            
            updatePatternDisplay();
            showAIStatus('✨ BEAST MODE SMART FILL!', '#2ecc71');
        }

        function showAIStatus(message, color) {
            const statusEl = document.getElementById('aiStatus');
            statusEl.textContent = message;
            statusEl.style.color = color;
            // NEW: Simplified the animation logic
            statusEl.style.opacity = '1';
            setTimeout(() => {
                statusEl.style.opacity = '0';
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 1000); // Wait for fade-out to complete before clearing text
            }, 3000);
        }

        function setupEventListeners() {
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('step-button')) {
                    initAudio();
                    
                    const track = parseInt(e.target.dataset.track);
                    const step = parseInt(e.target.dataset.step);
                    
                    patterns[track][step] = !patterns[track][step];
                    e.target.classList.toggle('active', patterns[track][step]);
                    
                    playSound(tracks[track].type, audioContext.currentTime, tracks[track].volume);
                }
            });

            document.getElementById('playBtn').addEventListener('click', () => {
                if (!isPlaying) {
                    startSequencer();
                } else {
                    pauseSequencer();
                }
            });

            document.getElementById('stopBtn').addEventListener('click', stopSequencer);
            document.getElementById('clearBtn').addEventListener('click', clearPattern);

            document.getElementById('tempoSlider').addEventListener('input', (e) => {
                tempo = parseInt(e.target.value);
                document.getElementById('tempoDisplay').textContent = tempo;
                updateSequenceInfo();
            });

            document.getElementById('sequenceLengthSelect').addEventListener('change', (e) => {
                updateSequenceLength(e.target.value);
            });

            document.getElementById('masterVolume').addEventListener('input', (e) => {
                if (masterGain) {
                    masterGain.gain.value = e.target.value / 100;
                }
            });

            // Effects controls
            document.getElementById('filterFreq').addEventListener('input', (e) => {
                if (filterNode) {
                    filterNode.frequency.value = e.target.value;
                }
            });

            document.getElementById('distortion').addEventListener('input', (e) => {
                if (distortionNode) {
                    const amount = e.target.value / 10;
                    distortionNode.curve = makeDistortionCurve(amount);
                }
            });

            document.getElementById('reverb').addEventListener('input', (e) => {
                if (reverbNode) {
                    // This is a placeholder as the reverb is not a simple gain control
                    // You would need to adjust the dry/wet mix here.
                    // For now, we'll make a simple change.
                    reverbNode.gain.value = e.target.value / 100;
                }
            });

            document.getElementById('delay').addEventListener('input', (e) => {
                // NEW: Correctly control the delay gain.
                if (delayGain) {
                    delayGain.gain.value = e.target.value / 100;
                }
            });

            document.addEventListener('input', (e) => {
                if (e.target.classList.contains('volume-slider')) {
                    const trackIndex = parseInt(e.target.dataset.track);
                    tracks[trackIndex].volume = e.target.value / 100;
                }
            });

            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('preset-btn')) {
                    const presetKey = e.target.dataset.preset;
                    const categoryKey = e.target.dataset.category || currentCategory;
                    loadPreset(presetKey, categoryKey);
                }
            });

            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('category-tab')) {
                    switchCategory(e.target.dataset.category);
                }
            });

            // Voice recording controls
            document.getElementById('recordVoiceBtn').addEventListener('click', () => {
                if (!isRecording) {
                    startVoiceRecording();
                } else {
                    stopVoiceRecording();
                }
            });

            document.getElementById('playVoiceBtn').addEventListener('click', playVoiceSample);
            document.getElementById('generateLyricsBtn').addEventListener('click', generateLyrics);

            // Export control
            document.getElementById('exportMp3Btn').addEventListener('click', exportToMP3);

            // AI controls
            document.getElementById('heartPattern').addEventListener('click', heartCurrentPattern);
            document.getElementById('evolvePattern').addEventListener('click', evolveCurrentPattern);
            document.getElementById('generateVariation').addEventListener('click', generateVariation);
            document.getElementById('smartFill').addEventListener('click', smartFill);

            document.addEventListener('keydown', (e) => {
                switch(e.code) {
                    case 'Space':
                        e.preventDefault();
                        if (!isPlaying) {
                            startSequencer();
                        } else {
                            pauseSequencer();
                        }
                        break;
                    case 'Escape':
                        stopSequencer();
                        break;
                    case 'KeyC':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            clearPattern();
                        }
                        break;
                    case 'KeyR':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            if (!isRecording) {
                                startVoiceRecording();
                            } else {
                                stopVoiceRecording();
                            }
                        }
                        break;
                    case 'KeyE':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            exportToMP3();
                        }
                        break;
                    case 'Digit1':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            document.getElementById('sequenceLengthSelect').value = '8';
                            updateSequenceLength(8);
                        }
                        break;
                    case 'Digit2':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            document.getElementById('sequenceLengthSelect').value = '16';
                            updateSequenceLength(16);
                        }
                        break;
                    case 'Digit3':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            document.getElementById('sequenceLengthSelect').value = '32';
                            updateSequenceLength(32);
                        }
                        break;
                    case 'Digit4':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            document.getElementById('sequenceLengthSelect').value = '64';
                            updateSequenceLength(64);
                        }
                        break;
                }
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            generateUI();
            generateCategoryTabs();
            generatePresetGrid();
            setupEventListeners();
            updatePatternDisplay();
            updateSequenceInfo();
            
            // Load a Prodigy preset by default
            loadPreset('firestarter', 'prodigy');
            
            showAIStatus('🔥 BEAST MODE ACTIVATED! Choose your sequence length and create FIRE! 🔥', '#00ff80');
        });
    </script>
</body>
</html>
